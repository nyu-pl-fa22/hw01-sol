## Problem 1: Regular Expressions

1.

```
letter ::= [A-Z] | [a-z] | _
digit ::= [0-9]

c_ident ::= letter (letter | digit)*
```

2.

```
digit ::= [0-9]
fdigit ::= [2-9]

tdigit ::= fdigit digit digit 
area ::= '(' tdigit ')' | tdigit
central ::= tdigit
subscriber ::= digit digit digit digit

number ::= area '.' central '.' subscriber | area - central - subscriber
```

3.

The following version allows strings of the form `"\503"`:

```
tdigit ::= [0-3]
odigit ::= [0-7]
octal ::= (odigit)? odigit | tdigit odigit odigit

hdigit ::= [0-9] | [a-f] | [A-F]
nzhdigit ::= [1-9] | [a-f] | [A-F]
nfzhdigit ::= [1-9] | [a-e] | [A-E]
nfhdigit ::= [0-9] | [a-e] | [A-E]
nahdigit ::= [0-9] | [b-f] | [B-F]

unicode ::= u (nzhdigit hdigit hdigit hdigit |
               0 (nzhdigit hdigit hdigit |
                  0 (nfzhdigit hdigit |
                     0 nahdigit |
                     (f | F) nfhdigit)))


escape ::= b | t | n | f | r | ''' | " | \ | octal | unicode

non-escape ::= [^", \, '\n', '\r']

string ::= "(non-escape | \ escape)*"
```

This version disallows `"\503"`:

```
non-odigit ::= [^0,1,2,3,4,5,6,7,",\,'\n','\r']

octalp ::= (odigit)? odigit non-odigit | tdigit odigit odigit

escapep ::= b | t | n | f | r | ''' | " | \ | octalp | unicode

string ::= "(non-escape | \ (escape \)* escapep)* (non-escape | escape)?"
```

## Problem 2: Context-Free Grammars

### Part 1

A. The grammar describes all non-empty words over alphabet {a,b} that
contain more occurrences of b than a.

To see this, we first observe that we can simplify the grammar by "inlining" the productions for non-terminals `M` and `C`. This yields:

   ```
    S ::= B+ 
    A ::= bAA | abA | aaB | a
    B ::= bbA | baB | b | aBB
   ```

Let us now rearrange the cases to see the symmetry between the productions for `A` and `B`:

   ```
    S ::= B+ 
    A ::= aaB | bAA | abA | a
    B ::= bbA | aBB | baB | b
   ```

Now observe that if we consider `A` as the start symbol of a grammar with the same productions as above, then this gives us the language of all non-empty words `w` over alphabet `{a,b}` such that 1. `w` contains more occurrences of `a` than `b` and 2) `w` contains at least one `b` unless `w=a`. We get the symmetric property with the roles of `a` and `b` reversed for the grammar that has `B` as its start symbol.

As an aside, we can prove the claim made in the previous paragraph formally using induction over the length of the words generated by the grammars that have `A`, respectively, `B` as start symbols. The proof follows a case analysis that decomposes the words based on the shape of the productions.

Concatenating words generated by `B` maintains the property that the resulting words contain more occurrences of `a` than `b`. Moreover, since `B` can produce the word consisting only of `b`, repeated concatenation of `b` allows us to construct all non-empty words that contain only `b`s. It follows that the language of the grammar starting in `S` contains all non-empty words over `{a,b}` with more occurrences of `b` than `a`.


B.

The grammar is ambiguous. So there is more than one possible derivation and parse tree. Here is one possibility (with epsilon leaves omitted):
```
                  S
                 / \
                M   B
               /   / \
              S   b   C
             / \
            M   B_
                | \
                b  C
                  / \
                 b   A
                    / \
                   a   C
```

### Part 2

```
           E
          /|\_
         / O  \
        N  |   E
        |  +  /|\_
        3    / O  \
            /  |   E
            E  /  /|\_
           /|\   E O  \
          N * N  | |   E
          |   |  N ** /|\
          5   6  |   E O E
                 8   | |  \
                     2 **  N
                           |
                           2
```