## Problem 1: Regular Expressions

1.

```
letter ::= [A-Z] | [a-z] | _
digit ::= [0-9]

c_ident ::= letter (letter | digit)*
```

2.

```
digit ::= [0-9]
fdigit ::= [2-9]

tdigit ::= fdigit digit digit 
area ::= '(' tdigit ')' | tdigit
central ::= tdigit
subscriber ::= digit digit digit digit

number ::= area '.' central '.' subscriber | area - central - subscriber
```

3.

The following version allows strings of the form `"\503"`:

```
tdigit ::= [0-3]
odigit ::= [0-7]
octal ::= (odigit)? odigit | tdigit odigit odigit

hdigit ::= [0-9] | [a-f] | [A-F]
nzhdigit ::= [1-9] | [a-f] | [A-F]
nfzhdigit ::= [1-9] | [a-e] | [A-E]
nfhdigit ::= [0-9] | [a-e] | [A-E]
nahdigit ::= [0-9] | [b-f] | [B-F]

unicode ::= u (nzhdigit hdigit hdigit hdigit |
               0 (nzhdigit hdigit hdigit |
                  0 (nfzhdigit hdigit |
                     0 nahdigit |
                     (f | F) nfhdigit)))


escape ::= b | t | n | f | r | ''' | " | \ | octal | unicode

non-escape ::= [^", \, '\n', '\r']

string ::= "(non-escape | \ escape)*"
```

This version disallows `"\503"`:

```
non-odigit ::= [^0,1,2,3,4,5,6,7,",\,'\n','\r']

octalp ::= (odigit)? odigit non-odigit | tdigit odigit odigit

escapep ::= b | t | n | f | r | ''' | " | \ | octalp | unicode

string ::= "(non-escape | \ (escape \)* escapep)* (non-escape | \ escape)*"
```

## Problem 2: Context-Free Grammars

### Part 1

A. The grammar describes all non-empty words over alphabet {a,b} that
contain more occurrences of b than a.

To see this, we first observe that we can simplify the grammar by "inlining" the productions for non-terminals `M` and `C`. This yields:

   ```
    S ::= B+ 
    A ::= bAA | abA | aaB | a
    B ::= bbA | baB | b | aBB
   ```

Let us now rearrange the cases to see the symmetry between the productions for `A` and `B`:

   ```
    S ::= B+ 
    A ::= aaB | bAA | abA | a
    B ::= bbA | aBB | baB | b
   ```

Now observe that if we consider `A` as the start symbol of a grammar with the same productions as above, then this gives us the language of all non-empty words `w` over alphabet `{a,b}` such that `w` has exactly one more `a` than `b`. We get the symmetric property with the roles of `a` and `b` reversed for the grammar that has `B` as its start symbol.

As an aside, we can prove the claim made in the previous paragraph formally using induction over the length of the words in the languages of the grammars that have `A`, respectively, `B` as start symbols. The proof follows a case analysis based on the first two letters of the word under consideration.

If follows from the above property that if `w` is a word obtained by concatenating words generated by `B` than `w` contains more occurrences of `b` than `a`. Conversely, observe that any word that has more occurrences of `b` than `a` can be decomposed into non-empty subwords that each have exactly one more `b` than `a`. Thus, the language of the grammar starting in `S` contains exactly all non-empty words over `{a,b}` with more occurrences of `b` than `a`.


B.

The grammar is ambiguous. So there is more than one possible derivation and parse tree. Here is one possibility (with epsilon leaves omitted):
```
                  S
                 / \
                M   B
               /   / \
              S   b   C
             / \
            M   B_
                | \
                b  C
                  / \
                 b   A
                    / \
                   a   C
```

### Part 2

```
           E
          /|\_
         / O  \
        N  |   E
        |  +  /|\_
        3    / O  \
            /  |   E
            E  /  /|\_
           /|\   E O  \
          N * N  | |   E
          |   |  N ** /|\
          5   6  |   E O E
                 8   | |  \
                     2 **  N
                           |
                           2
```